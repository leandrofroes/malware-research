# Author: Leandro FrÃ³es
# Date: 2024-05-21

# Tested hashes
# 6ed1b68de55791a6534ea96e721ff6a5662f2aefff471929d23638f854a80031
# 82278c23c97dd24a08c5a1300f2a2cfc293824e0d4b178f340962cd722941e6b
# eb64f5c3dc9df31f9a18f736763235703e6c09564f8176889191bb55d2c28198

import re
import sys
import struct
import pefile

from capstone import *
from capstone.x86 import *

def find_target_chunk(code_section: bytes) -> bytes:
    """
    Attempt to find the target chunk to use to look for the config in
    the CODE section.
    :param code_section: The CODE section content.
    :return: The target data chunk found if any.
    """
    # We are looking for the following pattern:
    #
    #00434f7b  8b15e8384600       mov     edx, dword [enc_config]
    #00434f81  8d45f4             lea     eax, [ebp-0xc]
    #00434f84  b901040000         mov     ecx, 0x401
    #00434f89  e84ef5fcff         call    system.@LStrFromPCharLen
    egg = b'\x8b\x15....\x8D\x45.\xB9..\x00\x00\xE8'

    rule = re.compile(egg)
    matches = list(rule.finditer(code_section))

    if not matches:
        return None

    # We define 0x200 here cause the key is not that far from the
    # matched address in the CODE section
    target_chunk = code_section[matches[0].start():matches[0].start() + 0x200]

    return target_chunk

def find_config_blob(target_chunk: bytes, data_section: bytes, data_section_base: int) -> bytes:
    """
    Attempt to find the encrypted/encoded config blob in the target data
    chunk.
    :param target_chunk: The data chunk used to look for the config.
    :param data_section: The DATA section content.
    :param data_section_base: The DATA section base address.
    :return: The config blob found if any.
    """
    cs = Cs(CS_ARCH_X86, CS_MODE_64)
    cs.detail = True
    cs.skipdata = True

    enc_config_rva = 0
    config_size = 0

    for inst in cs.disasm(target_chunk, 0, len(target_chunk)):
        # We only care about movs
        if inst.mnemonic != "mov":
            continue

        # Try to find the config address
        if inst.operands[1].type == X86_OP_MEM and inst.operands[0].reg == X86_REG_EDX:
            enc_config_ptr_va = inst.operands[1].value.mem.disp

            print("[+] INFO: Potential config found at:", hex(enc_config_ptr_va))

            enc_config_ptr_rva = enc_config_ptr_va - data_section_base
            enc_config_va = data_section[enc_config_ptr_rva:enc_config_ptr_rva+4]
            enc_config_va = struct.unpack('<I', enc_config_va)[0]
            enc_config_rva = enc_config_va - data_section_base

        # Try to find the config size
        if inst.operands[1].type == X86_OP_IMM and inst.operands[0].reg == X86_REG_ECX:
            config_size = inst.operands[1].value.imm
            print("[+] INFO: Config length:", hex(config_size))
        
        if enc_config_rva and config_size:
            break

    # Collect the encrypted/encoded config blob by dereferencing the 
    # pointer found in the DATA section
    enc_config = data_section[enc_config_rva:enc_config_rva+config_size]
    # Clean it up in case the full config size is not being used
    enc_config = enc_config.split(b"\x00\x00\x00")[0]

    return enc_config

def find_key(target_chunk: bytes, code_section_data: bytes, code_section_base: int) -> bytes:
    """
    Attempt to find the input XOR key used to decrypt/decode the config.
    :param target_chunk: The data chunk used to look for the key.
    :param code_section_data: The CODE section content.
    :param code_section_base: The CODE section base address.
    :return: The input XOR key found if any.
    """
    cs = Cs(CS_ARCH_X86, CS_MODE_64)
    cs.detail = True
    cs.skipdata = True

    key = None

    for inst in cs.disasm(target_chunk, 0, len(target_chunk)):
        # Try to find the address of the input key being passed to EDX
        if inst.mnemonic == "mov" and inst.operands[0].reg == X86_REG_EDX and inst.operands[1].type == X86_OP_IMM:
            key_va = inst.operands[1].value.imm
            key_rva = key_va - code_section_base
            # The size of the key is at addr - 4
            key_size = code_section_data[key_rva - 4:key_rva]
            key_size = int.from_bytes(key_size, byteorder="little")
            # Collect the key by dereferencing the pointer found
            key = code_section_data[key_rva:key_rva+key_size]
            break
    
    return key

def generate_final_key(key: bytes) -> bytes:
    """
    Generate the final XOR key by performing some calculations with
    the input key.
    :param key: The input key.
    :return: The key generated from the calculations.
    """
    final_key = bytearray()

    for i in range(len(key)):
        final_key.append(key[i] ^ (len(key) - i))

    return bytes(final_key)

def dec_config(enc_data: bytes, key: bytes) -> bytes:
    """
    Decrypt/decode the config blob using the provided XOR key.
    :param enc_data: The encrypted/encoded config blob.
    :param key: The XOR key to use.
    :return: The decrypted/decoded malware config.
    """
    index = 0
    config_data = bytearray()

    for b in enc_data:
        config_data.append(key[index] ^ b)
        index = (key[index] + index) % len(key)
    
    return bytes(config_data)

def main():
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} <file>")
        sys.exit(1)

    filename = sys.argv[1]

    pe = pefile.PE(filename)

    code_section_data = None
    code_section_rva = 0
    data_section_data = None
    data_section_rva = 0

    # Get both CODE and DATA sections data and RVA
    for section in pe.sections:
        if section.Name[:4] == b"CODE":
            code_section_data = section.get_data()
            code_section_rva = section.VirtualAddress
        if section.Name[:4] == b"DATA":
            data_section_data = section.get_data()
            data_section_rva = section.VirtualAddress

    assert code_section_data is not None
    assert code_section_rva != 0
    assert data_section_data is not None
    assert data_section_rva != 0

    # Get the base address of both CODE and DATA sections
    image_base = pe.OPTIONAL_HEADER.ImageBase
    code_section_base = image_base + code_section_rva
    data_section_base = image_base + data_section_rva

    target_chunk = find_target_chunk(code_section_data)

    if not target_chunk:
        print("[!] ERROR: Unable to find the target config chunk in the CODE section.")
        sys.exit(1)

    enc_config = find_config_blob(target_chunk, data_section_data, data_section_base)

    if not enc_config:
        print("[!] ERROR: Unable to find the config blob.")
        sys.exit(1)

    input_key = find_key(target_chunk, code_section_data, code_section_base)

    if not input_key:
        print("[!] ERROR: Unable to find the decryption key.")
        sys.exit(1)

    print("[+] INFO: Input key found:", input_key)

    xor_key = generate_final_key(input_key)

    print("[+] INFO: Final key generated:", xor_key)

    config_data = dec_config(enc_config, xor_key)

    print("[+] INFO: Config extracted:\n")
    print(config_data.decode())

if __name__ == "__main__":
    main()